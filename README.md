Теперь, когда у вас есть работающее приложение, давайте подведем итоги того, что вы создали. Вот снова структура приложения:

<img alt="model" src="/img/model.png" width="400"/>

Компоненты приложения:

MainActivity: отображает слова в списке, используя a RecyclerView и WordListAdapter. В MainActivity, есть инструмент, Observer который 
наблюдает за словами из базы данных и получает уведомление, когда они меняются.

NewWordActivity: добавляет новое слово в список.

WordViewModel: предоставляет методы для доступа к уровню данных и возвращает LiveData, 
чтобы MainActivity мог установить отношения наблюдателя. *

LiveData<List<Word>>: Делает возможным автоматическое обновление компонентов 
пользовательского интерфейса. Вы можете преобразовать из Flow, в LiveData, позвонив flow.toLiveData().

Repository:управляет одним или несколькими источниками данных. Предоставляет Repository методы для 
ViewModel для взаимодействия с базовым поставщиком данных. В этом приложении этим сервером является база данных Room.

Room: представляет собой оболочку и реализует базу данных SQLite. Room выполняет за вас много работы, которую раньше приходилось делать самому.

DAO: сопоставляет вызовы методов с запросами к базе данных, чтобы, когда Репозиторий вызывает такой метод, 
как getAlphabetizedWords()Room, может выполняться .SELECT * FROM word_table ORDER BY word ASC

DAO может предоставлять suspend запросы для одноразовых запросов и Flow запросов - когда вы хотите получать уведомления об изменениях в базе данных.

Word: - это класс сущности, содержащий одно слово.

Views и Activities(и Fragments) взаимодействуют с данными только через ViewModel. Таким образом, не имеет значения, откуда поступают данные.

Поток данных для автоматического обновления пользовательского интерфейса (реактивный пользовательский интерфейс)
Автоматическое обновление возможно, потому что вы используете LiveData. В MainActivity нем есть объект, 
Observer который наблюдает за словами LiveData из базы данных и получает уведомление, когда они меняются. 
Когда есть изменение, метод наблюдателя onChange()выполняется и обновляется mWordsв WordListAdapter.

Данные можно наблюдать, потому что они есть LiveData. И наблюдается то, LiveData<List<Word>>что 
возвращается WordViewModel allWords собственностью.

WordViewModelСкрывает все о внутреннем интерфейсе из слоя пользовательского интерфейса. 
Он предоставляет методы для доступа к уровню данных и возвращается, LiveData чтобы MainActivity можно 
было установить отношения наблюдателя. Viewsи Activities(и Fragments) взаимодействуют с данными только ч
ерез ViewModel. Таким образом, не имеет значения, откуда поступают данные.

В этом случае данные поступают из файла Repository. ViewModelНе нужно знать , что это Repository 
взаимодействует с. Ему просто нужно знать, как взаимодействовать с объектом Repository, то есть 
с помощью методов, предоставляемых Repository.

Репозиторий управляет одним или несколькими источниками данных. В WordListSample приложении это 
база данных Room. Room представляет собой оболочку и реализует базу данных SQLite. Room выполняет 
за вас много работы, которую раньше приходилось делать самому. Например, Room делает все, что вы делали с SQLiteOpenHelper классом.

DAO сопоставляет вызовы методов с запросами к базе данных, так что, когда репозиторий вызывает такой метод,
 как getAllWords()Room, может выполнятьсяSELECT * FROM word_table ORDER BY word ASC

.

Поскольку наблюдаются результат возвращается из запроса LiveData, каждый раз , 
когда данные в изменении комнаты, Observerинтерфейс onChanged()метод выполняется 
и пользовательский интерфейс обновляется.